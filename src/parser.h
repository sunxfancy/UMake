/**
 * @file parser.h
 * @brief Parser for umake
 */

#pragma once

#include <map>
#include <string>
#include <vector>

namespace umake {

struct Element {
    virtual std::string gen(bool debug = false) = 0;
    virtual ~Element() {}
};

/**
 * @brief Rule for umake
 * @details
 * The rule is the basic unit of umake grammar.
 * It's like the rule in makefile which contains the target,
 * dependencies, order-only dependencies, commands and attributes.
 *
 * However, the rule can be more flexible than makefile.
 * The target could be a directory, and it will only be done once the target
 * is generated completely.
 */
struct Rule : public Element {
    typedef std::vector<std::string>           StringList;
    typedef std::map<std::string, std::string> StringMap;
    bool                                       multiple;
    StringList                                 target;
    StringList dependencies, order_only_dependencies;
    StringList commands;
    StringMap  attrs;

    Rule(StringList *target, StringList *dependencies,
         StringList *order_only_dependencies, bool multiple,
         StringList *commands, StringMap *attrs);
    virtual ~Rule();

    std::string gen(bool debug = false);
    void gen_body(std::stringstream &ss, bool dd = false, bool debug = false);
};

struct Assignment : public Element {
    std::string              key;
    std::vector<std::string> value;
    std::string              assign;
    Assignment(std::string key, std::string assign,
               std::vector<std::string> *value)
        : key(key), value(*value), assign(assign) {
        delete value;
    }
    virtual ~Assignment() {};

    std::string gen(bool debug = false);
};

/**
 * @brief Parser for umake
 * @details
 * This class is a wrap of lexer and parser class for umake grammar.
 * The parser is generated by bison and flex.
 *
 * Call `Parse(input)` to parse the input string.
 * The rules will be added to `rules` vector.
 *
 * The function `add` is used to add a rule to `rules` vector.
 * But it should only be used by the parser itself.
 */
struct parser {
    void                  *lexer;
    const char            *lexer_buffer;
    std::vector<Element *> rules;

    ~parser() {
        for (auto rule : rules)
            delete rule;
    }

    void Parse(std::string input);
    void add(Element *rule) { rules.push_back(rule); }
};

} // namespace umake
