/**
 * @file parser.h
 * @brief Parser for umake
 */

#pragma once

#include <map>
#include <string>
#include <vector>

namespace umake {

/**
 * @brief Rule for umake
 * @details
 * The rule is the basic unit of umake grammar.
 * It's like the rule in makefile which contains the target, 
 * dependencies, order-only dependencies, commands and attributes.
 * 
 * However, the rule can be more flexible than makefile.
 * The target could be a directory, and it will only be done once the target
 * is generated completely.
 */
struct Rule {
    typedef std::vector<std::string>           StringList;
    typedef std::map<std::string, std::string> StringMap;
    bool                                       multiple;
    StringList                                 target;
    StringList dependencies, order_only_dependencies;
    StringList commands;
    StringMap  attrs;

    Rule(StringList *target, StringList *dependencies,
         StringList *order_only_dependencies, bool multiple,
         StringList *commands, StringMap *attrs);
    ~Rule();

    std::string gen(bool debug = false);
    void gen_body(std::stringstream &ss, bool dd = false, bool debug = false);
};

/**
 * @brief Parser for umake
 * @details
 * This class is a wrap of lexer and parser class for umake grammar.
 * The parser is generated by bison and flex.
 * 
 * Call `Parse(input)` to parse the input string.
 * The rules will be added to `rules` vector.
 * 
 * The function `add` is used to add a rule to `rules` vector.
 * But it should only be used by the parser itself.
 */
struct parser {
    void               *lexer;
    const char         *lexer_buffer;
    std::vector<Rule *> rules;

    ~parser() {
        for (auto rule : rules)
            delete rule;
    }

    void Parse(std::string input);
    void add(Rule *rule) { rules.push_back(rule); }
};

} // namespace umake
